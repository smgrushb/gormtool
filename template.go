package main

import "strings"

type codeBuilder struct{}

func init() {
	Build = &codeBuilder{}
}

func (b *codeBuilder) BuildTemplateMap(model *ModelInfo) map[string]interface{} {
	m := make(map[string]interface{})
	m["ModelName"] = model.Name
	m["ModelNameLower"] = strings.ToLower(model.Name)
	like := make([]ModelFieldInfo, 0)
	between := make([]ModelFieldInfo, 0)
	for _, v := range model.Fields {
		if v.Type == "string" {
			like = append(like, v)
		}
		if v.Type == "time.Time" || v.Type == "int" || v.Type == "int32" || v.Type == "int64" || v.Type == "float64" {
			between = append(between, v)
		}
	}
	m["Fields"] = model.Fields
	m["Like"] = like
	m["Between"] = between
	return m
}

func (b *codeBuilder) PackageKey() string {
	const key = "PackageName"
	return key
}

func (b *codeBuilder) HeaderTemplate() string {
	const template = `package {{.PackageName}}
// this file was generated by code. DO NOT EDIT.

import (
	"fmt"
	"time"

	"gorm.io/gorm"
)

var _, _, _ = fmt.Println, time.Now, gorm.Open
`
	return template
}

func (b *codeBuilder) ContentTemplate() string {
	const template = `
var (
	_{{.ModelNameLower}}Model = &{{.ModelName}}{}
	{{.ModelName}}Col = struct {
		{{- range .Fields}}
		{{.Name}} string
		{{- end}}
	}{
		{{- range .Fields}}
		{{.Name}}: "{{.Column}}", 
		{{- end}}
	}
)

type {{.ModelName}}Slice []*{{.ModelName}}

{{- range .Fields}}

func (s {{$.ModelName}}Slice) {{.Name}}List() []{{.Type}}{
	list := make([]{{.Type}}, len(s))
	for i, v := range s {
		list[i] = v.{{.Name}}
	}
	return list
}

func (s {{$.ModelName}}Slice) KeyBy{{.Name}}() map[{{.Type}}]*{{$.ModelName}}{
	m := make(map[{{.Type}}]*{{$.ModelName}}, len(s))
	for _, v := range s {
		m[v.{{.Name}}] = v
	}
	return m
}

func (s {{$.ModelName}}Slice) GroupBy{{.Name}}() map[{{.Type}}]{{$.ModelName}}Slice{
	m := make(map[{{.Type}}]{{$.ModelName}}Slice)
	for _, v := range s {
		if _, ok := m[v.{{.Name}}]; !ok {
			m[v.{{.Name}}] = make({{$.ModelName}}Slice, 0)
		}
		m[v.{{.Name}}] = append(m[v.{{.Name}}], v)
	}
	return m
}

{{- end}}

type {{.ModelNameLower}}UpdateMap map[string]interface{}

func New{{.ModelName}}UpdateMap() {{.ModelNameLower}}UpdateMap {
	return make(map[string]interface{})
}

func (m {{.ModelNameLower}}UpdateMap) Map() map[string]interface{} {
	return m
}

{{- range .Fields}}
{{- if not .PrimaryKey}}

func (m {{$.ModelNameLower}}UpdateMap) Update{{.Name}}(value {{.Type}}) {{$.ModelNameLower}}UpdateMap {
	m["{{.Column}}"] = value
	return m
}
{{- end -}}
{{end}}

type {{.ModelNameLower}}DB struct {
	*gorm.DB
	updateMap {{.ModelNameLower}}UpdateMap
}

func New{{.ModelName}}DB(db *gorm.DB) *{{.ModelNameLower}}DB {
	return &{{.ModelNameLower}}DB{DB: db.Model(_{{.ModelNameLower}}Model), updateMap: New{{.ModelName}}UpdateMap()}
}

func (db *{{.ModelNameLower}}DB) GetDB() *gorm.DB {
	return db.DB
}

func (db *{{.ModelNameLower}}DB) StartWhere() *{{.ModelNameLower}}Where {
	return new{{.ModelName}}Where(db)
}

func (db *{{$.ModelNameLower}}DB) UpdatesV2() error {
	return db.DB.Updates(db.updateMap.Map()).Error
}
{{- range .Fields}}
{{- if not .PrimaryKey}}

func (db *{{$.ModelNameLower}}DB) Update{{.Name}}(value {{.Type}}) *{{$.ModelNameLower}}DB {
	db.updateMap.Update{{.Name}}(value)
	return db
}
{{- end -}}
{{end}}

type {{.ModelNameLower}}Where struct {
	*{{.ModelNameLower}}DB
}

func new{{.ModelName}}Where(db *{{.ModelNameLower}}DB) *{{.ModelNameLower}}Where {
	return &{{.ModelNameLower}}Where{ {{.ModelNameLower}}DB: db }
}

func (where *{{.ModelNameLower}}Where) EndWhere() *{{.ModelNameLower}}DB{
	return where.{{.ModelNameLower}}DB
}

{{- range .Fields}}

func (where *{{$.ModelNameLower}}Where) {{.Name}}EQ(value {{.Type}}) *{{$.ModelNameLower}}Where {
	where.{{$.ModelNameLower}}DB.DB = where.{{$.ModelNameLower}}DB.Where("{{.Column}} = ?", value)
	return where
}

func (where *{{$.ModelNameLower}}Where) {{.Name}}NE(value {{.Type}}) *{{$.ModelNameLower}}Where {
	where.{{$.ModelNameLower}}DB.DB = where.{{$.ModelNameLower}}DB.Where("{{.Column}} != ?", value)
	return where
}

func (where *{{$.ModelNameLower}}Where) {{.Name}}In(value []{{.Type}}) *{{$.ModelNameLower}}Where {
	where.{{$.ModelNameLower}}DB.DB = where.{{$.ModelNameLower}}DB.Where("{{.Column}} in ?", value)
	return where
}

func (where *{{$.ModelNameLower}}Where) {{.Name}}NotIn(value []{{.Type}}) *{{$.ModelNameLower}}Where {
	where.{{$.ModelNameLower}}DB.DB = where.{{$.ModelNameLower}}DB.Where("{{.Column}} not in ?", value)
	return where
}
{{- end}}

{{- range .Like}}

func (where *{{$.ModelNameLower}}Where) {{.Name}}Like(value {{.Type}}) *{{$.ModelNameLower}}Where {
	where.{{$.ModelNameLower}}DB.DB = where.{{$.ModelNameLower}}DB.Where("{{.Column}} like ?", fmt.Sprintf("%%%s%%", value))
	return where
}
{{- end }}

{{- range .Between}}

func (where *{{$.ModelNameLower}}Where) {{.Name}}Between(left, right {{.Type}}) *{{$.ModelNameLower}}Where {
	where.{{$.ModelNameLower}}DB.DB = where.{{$.ModelNameLower}}DB.Where("{{.Column}} between ? and ?", left, right)
	return where
}

func (where *{{$.ModelNameLower}}Where) {{.Name}}NotBetween(left, right {{.Type}}) *{{$.ModelNameLower}}Where {
	where.{{$.ModelNameLower}}DB.DB = where.{{$.ModelNameLower}}DB.Where("{{.Column}} not between ? and ?", left, right)
	return where
}
{{- end}}
`
	return template
}

func (b *codeBuilder) FileMaxSize() int {
	const size = 2e4
	return size
}
